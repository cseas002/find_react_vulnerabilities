import { NextRequest, NextResponse } from 'next/server';
import { execFile } from 'child_process';
import path from 'path';
import util from 'util';

const execFilePromise = util.promisify(execFile);

export async function POST(request: NextRequest) {
    try {
        const body = await request.json();
        const {
            projectPath,
            addCsp,
            indexPath,
            deleteOldCsp,
            cspType
        } = body;

        if (!projectPath || typeof projectPath !== 'string') {
            return NextResponse.json({ error: 'Project path is required and must be a string.' }, { status: 400 });
        }

        // IMPORTANT: Construct the path to generate_csp.py relative to the workspace root
        // The API route runs from within .next/server/app/api/generate-csp typically
        // process.cwd() for the Next.js server process is usually the root of the Next.js project (vulnerability-scanner)
        // So we need to go up one level to the workspace root `find_react_vulnerabilities`
        const scriptPath = path.resolve(process.cwd(), '..', 'generate_csp.py');
        const workspaceRootPath = path.resolve(process.cwd(), '..');

        // The projectPath from the client is relative to the workspace root.
        // We need to make sure the script receives it as such.
        // No change needed for projectPath itself if the script handles it correctly as relative to where it's run from (workspaceRootPath)

        const args: string[] = [projectPath];

        if (addCsp) {
            args.push('--add-csp');
            if (indexPath && typeof indexPath === 'string') {
                args.push('--index-path', indexPath);
            }
            if (deleteOldCsp) {
                args.push('--delete-old-csp');
            }
            if (cspType === 'production') {
                args.push('--production');
            } else if (cspType === 'development') {
                args.push('--development');
            } else {
                return NextResponse.json({ error: 'CSP type (production/development) is required when adding CSP to HTML.' }, { status: 400 });
            }
        }

        console.log(`Executing script: python3 ${scriptPath} ${args.join(' ')} from cwd: ${workspaceRootPath}`);

        try {
            const { stdout, stderr } = await execFilePromise('python3', [scriptPath, ...args], { cwd: workspaceRootPath });

            if (stderr && !stderr.toLowerCase().includes('warning')) {
                // Treat stderr as an error if it's not just a warning
                // Some scripts might output warnings to stderr but still succeed
                console.error('Python script stderr:', stderr);
                // Send back a mix of stdout and stderr if stderr seems like an error context
                return NextResponse.json({ output: stdout + "\n--- Errors ---\n" + stderr });
            }

            return NextResponse.json({ output: stdout + (stderr ? "\n--- Warnings ---\n" + stderr : "") });

        } catch (e: any) {
            console.error('Error executing Python script:', e);
            // e.stdout and e.stderr might contain output even if the script exited with an error code
            const output = e.stdout ? `Output:\n${e.stdout}` : '';
            const errOutput = e.stderr ? `Error Output:\n${e.stderr}` : '';
            const exitCode = e.code ? `Exit Code: ${e.code}` : '';
            return NextResponse.json({ error: `Failed to execute CSP script. ${exitCode}\n${output}\n${errOutput}\nError: ${e.message}`.trim() }, { status: 500 });
        }

    } catch (error) {
        console.error('Error in API route:', error);
        return NextResponse.json({ error: 'Invalid request body or internal server error.' }, { status: 500 });
    }
} 